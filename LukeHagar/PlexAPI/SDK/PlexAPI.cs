//------------------------------------------------------------------------------
// <auto-generated>
// This code was generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
//
// Changes to this file may cause incorrect behavior and will be lost when
// the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
#nullable enable
namespace LukeHagar.PlexAPI.SDK
{
    using LukeHagar.PlexAPI.SDK.Hooks;
    using LukeHagar.PlexAPI.SDK.Models.Components;
    using LukeHagar.PlexAPI.SDK.Models.Errors;
    using LukeHagar.PlexAPI.SDK.Utils;
    using LukeHagar.PlexAPI.SDK.Utils.Retries;
    using Newtonsoft.Json;
    using System;
    using System.Collections.Generic;
    using System.Net.Http;
    using System.Threading.Tasks;


    public interface IPlexAPI
    {

        /// <summary>
        /// General endpoints for basic PMS operation not specific to any media provider
        /// </summary>
        public IGeneral General { get; }

        /// <summary>
        /// The server can notify clients in real-time of a wide range of events, from library scanning, to preferences being modified, to changes to media, and many other things. This is also the mechanism by which activity progress is reported.<br/>
        /// 
        /// <remarks>
        /// <br/>
        /// Two protocols for receiving the events are available: EventSource (also known as SSE), and WebSocket.<br/>
        /// 
        /// </remarks>
        /// </summary>
        public IEvents Events { get; }

        /// <summary>
        /// API Operations against the Preferences
        /// </summary>
        public IPreferences Preferences { get; }

        /// <summary>
        /// Operations for rating media items (thumbs up/down, star ratings, etc.)
        /// </summary>
        public IRate Rate { get; }

        /// <summary>
        /// The actions feature within a media provider
        /// </summary>
        public ITimeline Timeline { get; }

        /// <summary>
        /// Activities provide a way to monitor and control asynchronous operations on the server. In order to receive real-time updates for activities, a client would normally subscribe via either EventSource or Websocket endpoints.<br/>
        /// 
        /// <remarks>
        /// <br/>
        /// Activities are associated with HTTP replies via a special `X-Plex-Activity` header which contains the UUID of the activity.<br/>
        /// <br/>
        /// Activities are optional cancellable. If cancellable, they may be cancelled via the `DELETE` endpoint.<br/>
        /// 
        /// </remarks>
        /// </summary>
        public IActivities Activities { get; }

        /// <summary>
        /// The butler is responsible for running periodic tasks.  Some tasks run daily, others every few days, and some weekly.  These includes database maintenance, metadata updating, thumbnail generation, media analysis, and other tasks.
        /// </summary>
        public IButler Butler { get; }

        /// <summary>
        /// API Operations against the Download Queue
        /// </summary>
        public IDownloadQueue DownloadQueue { get; }

        /// <summary>
        /// The hubs within a media provider
        /// </summary>
        public IHubs Hubs { get; }

        /// <summary>
        /// The search feature within a media provider
        /// </summary>
        public ISearch Search { get; }

        /// <summary>
        /// Library endpoints which are outside of the Media Provider API.  Typically this is manipulation of the library (adding/removing sections, modifying preferences, etc).
        /// </summary>
        public ILibrary Library { get; }

        /// <summary>
        /// API Operations against the Collections
        /// </summary>
        public ICollections Collections { get; }

        /// <summary>
        /// The DVR provides means to watch and record live TV.  This section of endpoints describes how to setup the DVR itself<br/>
        /// 
        /// <remarks>
        /// 
        /// </remarks>
        /// </summary>
        public IDVRs DVRs { get; }

        /// <summary>
        /// The EPG (Electronic Program Guide) is responsible for obtaining metadata for what is airing on each channel and when<br/>
        /// 
        /// <remarks>
        /// 
        /// </remarks>
        /// </summary>
        public IEpg Epg { get; }

        /// <summary>
        /// LiveTV contains the playback sessions of a channel from a DVR device<br/>
        /// 
        /// <remarks>
        /// 
        /// </remarks>
        /// </summary>
        public ILiveTV LiveTV { get; }

        /// <summary>
        /// Logging mechanism to allow clients to log to the server
        /// </summary>
        public ILog Log { get; }

        /// <summary>
        /// Media grabbers provide ways for media to be obtained for a given protocol. The simplest ones are `stream` and `download`. More complex grabbers can have associated devices<br/>
        /// 
        /// <remarks>
        /// <br/>
        /// Network tuners can present themselves on the network using the Simple Service Discovery Protocol and Plex Media Server will discover them. The following XML is an example of the data returned from SSDP. The `deviceType`, `serviceType`, and `serviceId` values must remain as they are in the example in order for PMS to properly discover the device. Other less-obvious fields are described in the parameters section below.<br/>
        /// <br/>
        /// Example SSDP output<br/>
        /// ```<br/>
        /// &lt;root xmlns=&quot;urn:schemas-upnp-org:device-1-0&quot;&gt;<br/>
        ///     &lt;specVersion&gt;<br/>
        ///         &lt;major&gt;1&lt;/major&gt;<br/>
        ///         &lt;minor&gt;0&lt;/minor&gt;<br/>
        ///     &lt;/specVersion&gt;<br/>
        ///     &lt;device&gt;<br/>
        ///         &lt;deviceType&gt;urn:plex-tv:device:Media:1&lt;/deviceType&gt;<br/>
        ///         &lt;friendlyName&gt;Turing Hopper 3000&lt;/friendlyName&gt;<br/>
        ///         &lt;manufacturer&gt;Plex, Inc.&lt;/manufacturer&gt;<br/>
        ///         &lt;manufacturerURL&gt;https://plex.tv/&lt;/manufacturerURL&gt;<br/>
        ///         &lt;modelDescription&gt;Turing Hopper 3000 Media Grabber&lt;/modelDescription&gt;<br/>
        ///         &lt;modelName&gt;Plex Media Grabber&lt;/modelName&gt;<br/>
        ///         &lt;modelNumber&gt;1&lt;/modelNumber&gt;<br/>
        ///         &lt;modelURL&gt;https://plex.tv&lt;/modelURL&gt;<br/>
        ///         &lt;UDN&gt;uuid:42fde8e4-93b6-41e5-8a63-12d848655811&lt;/UDN&gt;<br/>
        ///         &lt;serviceList&gt;<br/>
        ///             &lt;service&gt;<br/>
        ///                 &lt;URLBase&gt;http://10.0.0.5:8088&lt;/URLBase&gt;<br/>
        ///                 &lt;serviceType&gt;urn:plex-tv:service:MediaGrabber:1&lt;/serviceType&gt;<br/>
        ///                 &lt;serviceId&gt;urn:plex-tv:serviceId:MediaGrabber&lt;/serviceId&gt;<br/>
        ///             &lt;/service&gt;<br/>
        ///         &lt;/serviceList&gt;<br/>
        ///     &lt;/device&gt;<br/>
        /// &lt;/root&gt;<br/>
        /// ```<br/>
        /// <br/>
        ///   - UDN: (string) A UUID for the device. This should be unique across models of a device at minimum.<br/>
        ///   - URLBase: (string) The base HTTP URL for the device from which all of the other endpoints are hosted.<br/>
        /// 
        /// </remarks>
        /// </summary>
        public IDevices Devices { get; }

        /// <summary>
        /// Media providers are the starting points for the entire Plex Media Server media library API.  It defines the paths for the groups of endpoints.  The `/media/providers` should be the only hard-coded path in clients when accessing the media library.  Non-media library endpoints are outside the scope of the media provider.  See the description in See <a href="#section/API-Info/Media-Providers">the section in API Info</a> for more information on how to use media providers.
        /// </summary>
        public IProvider Provider { get; }

        /// <summary>
        /// Subscriptions determine which media will be recorded and the criteria for selecting an airing when multiple are available<br/>
        /// 
        /// <remarks>
        /// 
        /// </remarks>
        /// </summary>
        public ISubscriptions Subscriptions { get; }

        /// <summary>
        /// API Operations against the Transcoder
        /// </summary>
        public ITranscoder Transcoder { get; }

        /// <summary>
        /// Media playlists that can be created and played back
        /// </summary>
        public IPlaylist Playlist { get; }

        /// <summary>
        /// Endpoints for manipulating playlists.
        /// </summary>
        public ILibraryPlaylists LibraryPlaylists { get; }

        /// <summary>
        /// The playqueue feature within a media provider<br/>
        /// 
        /// <remarks>
        /// A play queue represents the current list of media for playback. Although queues are persisted by the server, they should be regarded by the user as a fairly lightweight, an ephemeral list of items queued up for playback in a session.  There is generally one active queue for each type of media (music, video, photos) that can be added to or destroyed and replaced with a fresh queue.<br/>
        /// Play Queues has a region, which we refer to in this doc (partially for historical reasons) as &quot;Up Next&quot;. This region is defined by `playQueueLastAddedItemID` existing on the media container. This follows iTunes&apos; terminology. It is a special region after the currently playing item but before the originally-played items. This enables &quot;Party Mode&quot; listening/viewing, where items can be added on-the-fly, and normal queue playback resumed when completed. <br/>
        /// You can visualize the play queue as a sliding window in the complete list of media queued for playback. This model is important when scaling to larger play queues (e.g. shuffling 40,000 audio tracks). The client only needs visibility into small areas of the queue at any given time, and the server can optimize access in this fashion.<br/>
        /// All created play queues will have an empty &quot;Up Next&quot; area - unless the item is an album and no `key` is provided. In this case the &quot;Up Next&quot; area will be populated by the contents of the album. This is to allow queueing of multiple albums - since the &apos;Add to Up Next&apos; will insert after all the tracks. This means that If you&apos;re creating a PQ from an album, you can only shuffle it if you set `key`. This is due to the above implicit queueing of albums when no `key` is provided as well as the current limitation that you cannot shuffle a PQ with an &quot;Up Next&quot; area.<br/>
        /// The play queue window advances as the server receives timeline requests. The client needs to retrieve the play queue as the “now playing” item changes. There is no play queue API to update the playing item.
        /// </remarks>
        /// </summary>
        public IPlayQueue PlayQueue { get; }

        /// <summary>
        /// Service provided to compute UltraBlur colors and images.
        /// </summary>
        public IUltraBlur UltraBlur { get; }

        /// <summary>
        /// The status endpoints give you information about current playbacks, play history, and even terminating sessions.
        /// </summary>
        public IStatus Status { get; }

        /// <summary>
        /// This describes the API for searching and applying updates to the Plex Media Server.<br/>
        /// 
        /// <remarks>
        /// Updates to the status can be observed via the Event API.<br/>
        /// 
        /// </remarks>
        /// </summary>
        public IUpdater Updater { get; }

        /// <summary>
        /// The actual content of the media provider
        /// </summary>
        public IContent Content { get; }

        /// <summary>
        /// Endpoints for manipulating collections.  In addition to these endpoints, `/library/collections/:collectionId/X` will be rerouted to `/library/metadata/:collectionId/X` and respond to those endpoints as well.
        /// </summary>
        public ILibraryCollections LibraryCollections { get; }
    }


    public class PlexAPI: IPlexAPI
    {
        public SDKConfig SDKConfiguration { get; private set; }

        private const string _language = "csharp";
        private const string _sdkVersion = "0.19.1";
        private const string _sdkGenVersion = "2.753.1";
        private const string _openapiDocVersion = "1.1.1";
        public IGeneral General { get; private set; }
        public IEvents Events { get; private set; }
        public IPreferences Preferences { get; private set; }
        public IRate Rate { get; private set; }
        public ITimeline Timeline { get; private set; }
        public IActivities Activities { get; private set; }
        public IButler Butler { get; private set; }
        public IDownloadQueue DownloadQueue { get; private set; }
        public IHubs Hubs { get; private set; }
        public ISearch Search { get; private set; }
        public ILibrary Library { get; private set; }
        public ICollections Collections { get; private set; }
        public IDVRs DVRs { get; private set; }
        public IEpg Epg { get; private set; }
        public ILiveTV LiveTV { get; private set; }
        public ILog Log { get; private set; }
        public IDevices Devices { get; private set; }
        public IProvider Provider { get; private set; }
        public ISubscriptions Subscriptions { get; private set; }
        public ITranscoder Transcoder { get; private set; }
        public IPlaylist Playlist { get; private set; }
        public ILibraryPlaylists LibraryPlaylists { get; private set; }
        public IPlayQueue PlayQueue { get; private set; }
        public IUltraBlur UltraBlur { get; private set; }
        public IStatus Status { get; private set; }
        public IUpdater Updater { get; private set; }
        public IContent Content { get; private set; }
        public ILibraryCollections LibraryCollections { get; private set; }

        public PlexAPI(SDKConfig config)
        {
            SDKConfiguration = config;
            InitHooks();

            General = new General(SDKConfiguration);

            Events = new Events(SDKConfiguration);

            Preferences = new Preferences(SDKConfiguration);

            Rate = new Rate(SDKConfiguration);

            Timeline = new Timeline(SDKConfiguration);

            Activities = new Activities(SDKConfiguration);

            Butler = new Butler(SDKConfiguration);

            DownloadQueue = new DownloadQueue(SDKConfiguration);

            Hubs = new Hubs(SDKConfiguration);

            Search = new Search(SDKConfiguration);

            Library = new Library(SDKConfiguration);

            Collections = new Collections(SDKConfiguration);

            DVRs = new DVRs(SDKConfiguration);

            Epg = new Epg(SDKConfiguration);

            LiveTV = new LiveTV(SDKConfiguration);

            Log = new Log(SDKConfiguration);

            Devices = new Devices(SDKConfiguration);

            Provider = new Provider(SDKConfiguration);

            Subscriptions = new Subscriptions(SDKConfiguration);

            Transcoder = new Transcoder(SDKConfiguration);

            Playlist = new Playlist(SDKConfiguration);

            LibraryPlaylists = new LibraryPlaylists(SDKConfiguration);

            PlayQueue = new PlayQueue(SDKConfiguration);

            UltraBlur = new UltraBlur(SDKConfiguration);

            Status = new Status(SDKConfiguration);

            Updater = new Updater(SDKConfiguration);

            Content = new Content(SDKConfiguration);

            LibraryCollections = new LibraryCollections(SDKConfiguration);
        }

        /// <summary>
        /// Initializes a new instance of the SDK with optional configuration parameters.
        /// </summary>
        /// <param name="token">The security configuration to use for API requests. If provided, this will be used as a static security configuration.</param>
        /// <param name="tokenSource">A function that returns the security configuration dynamically. This takes precedence over the static security parameter if both are provided.</param>
        /// <param name="accepts">Indicates the client accepts the indicated media types</param>
        /// <param name="clientIdentifier">An opaque identifier unique to the client</param>
        /// <param name="product">The name of the client product</param>
        /// <param name="version">The version of the client application</param>
        /// <param name="platform">The platform of the client</param>
        /// <param name="platformVersion">The version of the platform</param>
        /// <param name="device">A relatively friendly name for the client device</param>
        /// <param name="model">A potentially less friendly identifier for the device model</param>
        /// <param name="deviceVendor">The device vendor</param>
        /// <param name="deviceName">A friendly name for the client</param>
        /// <param name="marketplace">The marketplace on which the client application is distributed</param>
        /// <param name="serverIndex">The index of the server to use from the predefined server list. Must be between 0 and the length of the server list. Defaults to 0 if not specified.</param>
        /// <param name="identifier">Server variable for identifier. This will replace the {identifier} placeholder in server URLs.</param>
        /// <param name="ipDescription">Server variable for IP-description. This will replace the {IP-description} placeholder in server URLs.</param>
        /// <param name="port">Server variable for port. This will replace the {port} placeholder in server URLs.</param>
        /// <param name="protocol">Server variable for protocol. This will replace the {protocol} placeholder in server URLs.</param>
        /// <param name="host">Server variable for host. This will replace the {host} placeholder in server URLs.</param>
        /// <param name="fullServerUrl">Server variable for full_server_url. This will replace the {full_server_url} placeholder in server URLs.</param>
        /// <param name="serverUrl">A custom server URL to use instead of the predefined server list. If provided with urlParams, the URL will be templated with the provided parameters.</param>
        /// <param name="urlParams">A dictionary of parameters to use for templating the serverUrl. Only used when serverUrl is provided.</param>
        /// <param name="client">A custom HTTP client implementation to use for making API requests. If not provided, the default SpeakeasyHttpClient will be used.</param>
        /// <param name="retryConfig">Configuration for retry behavior when API requests fail. Defines retry strategies, backoff policies, and maximum retry attempts.</param>
        /// <exception cref="Exception">Thrown when the serverIndex is out of range (less than 0 or greater than or equal to the server list length).</exception>
        public PlexAPI(string? token = null, Func<string>? tokenSource = null, Accepts? accepts = null, string? clientIdentifier = null, string? product = null, string? version = null, string? platform = null, string? platformVersion = null, string? device = null, string? model = null, string? deviceVendor = null, string? deviceName = null, string? marketplace = null, int? serverIndex = null, string? identifier = null, string? ipDescription = null, string? port = null, string? protocol = null, string? host = null, string? fullServerUrl = null, string? serverUrl = null, Dictionary<string, string>? urlParams = null, ISpeakeasyHttpClient? client = null, RetryConfig? retryConfig = null)
        {
            if (serverIndex != null)
            {
                if (serverIndex.Value < 0 || serverIndex.Value >= SDKConfig.ServerList.Length)
                {
                    throw new Exception($"Invalid server index {serverIndex.Value}");
                }
            }

            if (serverUrl != null)
            {
                if (urlParams != null)
                {
                    serverUrl = Utilities.TemplateUrl(serverUrl, urlParams);
                }
            }
            Func<LukeHagar.PlexAPI.SDK.Models.Components.Security>? _securitySource = null;

            if(tokenSource != null)
            {
                _securitySource = () => new LukeHagar.PlexAPI.SDK.Models.Components.Security() { Token = tokenSource() };
            }
            else if(token != null)
            {
                _securitySource = () => new LukeHagar.PlexAPI.SDK.Models.Components.Security() { Token = token };
            }

            SDKConfiguration = new SDKConfig(client)
            {
                Accepts = accepts,
                ClientIdentifier = clientIdentifier,
                Product = product,
                Version = version,
                Platform = platform,
                PlatformVersion = platformVersion,
                Device = device,
                Model = model,
                DeviceVendor = deviceVendor,
                DeviceName = deviceName,
                Marketplace = marketplace,
                ServerIndex = serverIndex == null ? 0 : serverIndex.Value,
                ServerUrl = serverUrl == null ? "" : serverUrl,
                SecuritySource = _securitySource,
                RetryConfig = retryConfig
            };

            if (identifier != null)
            {
                SDKConfiguration.SetServerVariable("identifier", identifier);
            }

            if (ipDescription != null)
            {
                SDKConfiguration.SetServerVariable("IP-description", ipDescription);
            }

            if (port != null)
            {
                SDKConfiguration.SetServerVariable("port", port);
            }

            if (protocol != null)
            {
                SDKConfiguration.SetServerVariable("protocol", protocol);
            }

            if (host != null)
            {
                SDKConfiguration.SetServerVariable("host", host);
            }

            if (fullServerUrl != null)
            {
                SDKConfiguration.SetServerVariable("full_server_url", fullServerUrl);
            }

            InitHooks();

            General = new General(SDKConfiguration);

            Events = new Events(SDKConfiguration);

            Preferences = new Preferences(SDKConfiguration);

            Rate = new Rate(SDKConfiguration);

            Timeline = new Timeline(SDKConfiguration);

            Activities = new Activities(SDKConfiguration);

            Butler = new Butler(SDKConfiguration);

            DownloadQueue = new DownloadQueue(SDKConfiguration);

            Hubs = new Hubs(SDKConfiguration);

            Search = new Search(SDKConfiguration);

            Library = new Library(SDKConfiguration);

            Collections = new Collections(SDKConfiguration);

            DVRs = new DVRs(SDKConfiguration);

            Epg = new Epg(SDKConfiguration);

            LiveTV = new LiveTV(SDKConfiguration);

            Log = new Log(SDKConfiguration);

            Devices = new Devices(SDKConfiguration);

            Provider = new Provider(SDKConfiguration);

            Subscriptions = new Subscriptions(SDKConfiguration);

            Transcoder = new Transcoder(SDKConfiguration);

            Playlist = new Playlist(SDKConfiguration);

            LibraryPlaylists = new LibraryPlaylists(SDKConfiguration);

            PlayQueue = new PlayQueue(SDKConfiguration);

            UltraBlur = new UltraBlur(SDKConfiguration);

            Status = new Status(SDKConfiguration);

            Updater = new Updater(SDKConfiguration);

            Content = new Content(SDKConfiguration);

            LibraryCollections = new LibraryCollections(SDKConfiguration);
        }

        private void InitHooks()
        {
            string preHooksUrl = SDKConfiguration.GetTemplatedServerUrl();
            var (postHooksUrl, postHooksClient) = SDKConfiguration.Hooks.SDKInit(preHooksUrl, SDKConfiguration.Client);
            var config = SDKConfiguration;
            if (preHooksUrl != postHooksUrl)
            {
                config.ServerUrl = postHooksUrl;
            }
            config.Client = postHooksClient;
            SDKConfiguration = config;
        }

        public class SDKBuilder
        {
            private SDKConfig _sdkConfig = new SDKConfig(client: new SpeakeasyHttpClient());

            public SDKBuilder() { }

            public SDKBuilder WithServerIndex(int serverIndex)
            {
                if (serverIndex < 0 || serverIndex >= SDKConfig.ServerList.Length)
                {
                    throw new Exception($"Invalid server index {serverIndex}");
                }
                _sdkConfig.ServerIndex = serverIndex;
                return this;
            }

            public SDKBuilder WithIdentifier(string identifier)
            {
                _sdkConfig.SetServerVariable("identifier", identifier);
                return this;
            }

            public SDKBuilder WithIPDescription(string ipDescription)
            {
                _sdkConfig.SetServerVariable("IP-description", ipDescription);
                return this;
            }

            public SDKBuilder WithPort(string port)
            {
                _sdkConfig.SetServerVariable("port", port);
                return this;
            }

            public SDKBuilder WithProtocol(string protocol)
            {
                _sdkConfig.SetServerVariable("protocol", protocol);
                return this;
            }

            public SDKBuilder WithHost(string host)
            {
                _sdkConfig.SetServerVariable("host", host);
                return this;
            }

            public SDKBuilder WithFullServerUrl(string fullServerUrl)
            {
                _sdkConfig.SetServerVariable("full_server_url", fullServerUrl);
                return this;
            }

            public SDKBuilder WithServerUrl(string serverUrl, Dictionary<string, string>? serverVariables = null)
            {
                if (serverVariables != null)
                {
                    serverUrl = Utilities.TemplateUrl(serverUrl, serverVariables);
                }
                _sdkConfig.ServerUrl = serverUrl;
                return this;
            }

            public SDKBuilder WithAccepts(Accepts accepts)
            {
                _sdkConfig.Accepts = accepts;
                return this;
            }

            public SDKBuilder WithClientIdentifier(string clientIdentifier)
            {
                _sdkConfig.ClientIdentifier = clientIdentifier;
                return this;
            }

            public SDKBuilder WithProduct(string product)
            {
                _sdkConfig.Product = product;
                return this;
            }

            public SDKBuilder WithVersion(string version)
            {
                _sdkConfig.Version = version;
                return this;
            }

            public SDKBuilder WithPlatform(string platform)
            {
                _sdkConfig.Platform = platform;
                return this;
            }

            public SDKBuilder WithPlatformVersion(string platformVersion)
            {
                _sdkConfig.PlatformVersion = platformVersion;
                return this;
            }

            public SDKBuilder WithDevice(string device)
            {
                _sdkConfig.Device = device;
                return this;
            }

            public SDKBuilder WithModel(string model)
            {
                _sdkConfig.Model = model;
                return this;
            }

            public SDKBuilder WithDeviceVendor(string deviceVendor)
            {
                _sdkConfig.DeviceVendor = deviceVendor;
                return this;
            }

            public SDKBuilder WithDeviceName(string deviceName)
            {
                _sdkConfig.DeviceName = deviceName;
                return this;
            }

            public SDKBuilder WithMarketplace(string marketplace)
            {
                _sdkConfig.Marketplace = marketplace;
                return this;
            }

            public SDKBuilder WithTokenSource(Func<string> tokenSource)
            {
                _sdkConfig.SecuritySource = () => new LukeHagar.PlexAPI.SDK.Models.Components.Security() { Token = tokenSource() };
                return this;
            }

            public SDKBuilder WithToken(string token)
            {
                _sdkConfig.SecuritySource = () => new LukeHagar.PlexAPI.SDK.Models.Components.Security() { Token = token };
                return this;
            }

            public SDKBuilder WithClient(ISpeakeasyHttpClient client)
            {
                _sdkConfig.Client = client;
                return this;
            }

            public SDKBuilder WithRetryConfig(RetryConfig retryConfig)
            {
                _sdkConfig.RetryConfig = retryConfig;
                return this;
            }

            public PlexAPI Build()
            {
              return new PlexAPI(_sdkConfig);
            }

        }

        public static SDKBuilder Builder() => new SDKBuilder();
    }
}